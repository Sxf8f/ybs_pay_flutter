import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:ybs_pay/core/const/assets_const.dart';


class signUpRepository{
  Future<String>signUp({
    required String username,
    required String email,
    required String password,
    required String phoneNumber,
    required String pinCode,
    required String address,
}) async{
    final uri= Uri.parse('${AssetsConst.apiBase}api/register/');
    
    // Prepare request body as JSON
    final body = jsonEncode({
      'username': username,
      'email': email,
      // Password is auto-generated by server, not sent
      'phone_number': phoneNumber,
      'pincode': pinCode,
      'address': address
    });
    
    // Set proper headers for JSON content
    final headers = {
      'Content-Type': 'application/json',
    };
    
    final response = await http.post(uri, headers: headers, body: body);
    
    if(response.statusCode == 201){
      final data = json.decode(response.body);
      return data['message'] ?? 'Signup Successful';
    } else {
      // Parse error response - could be field-specific errors or general error
      final errorData = json.decode(response.body);
      
      // Handle field-specific validation errors
      if (errorData is Map<String, dynamic>) {
        final errorMessages = <String>[];
        
        // Collect all field errors
        errorData.forEach((key, value) {
          if (value is List) {
            errorMessages.addAll(value.map((e) => e.toString()));
          } else if (value is String) {
            errorMessages.add(value);
          }
        });
        
        // Handle non_field_errors if present
        if (errorData.containsKey('non_field_errors')) {
          final nonFieldErrors = errorData['non_field_errors'];
          if (nonFieldErrors is List) {
            errorMessages.addAll(nonFieldErrors.map((e) => e.toString()));
          }
        }
        
        // Handle status/message format
        if (errorData.containsKey('message')) {
          errorMessages.add(errorData['message'].toString());
        }
        
        if (errorMessages.isNotEmpty) {
          throw Exception(errorMessages.join(', '));
        }
      }
      
      throw Exception(errorData.toString());
    }
  }
}
